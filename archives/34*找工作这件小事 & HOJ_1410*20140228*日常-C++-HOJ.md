# 找工作这件小事 & HOJ_1410  

今天对面寝的一个国防生哥们儿来我们寝玩，说他应该要去新西兰了。  

我当时就纳闷了，你一个当兵的，出国有这么容易么？  

然后他就解释了，新西兰就是，新(和谐)疆，西(和谐)藏，兰州。。。  

当时就笑喷了~  

不过乐归乐，这也能看出我身边的人都已经开始考虑以后的出路了，今天上午和豆豆一起把简历弄好了，感觉把我能写的都写了上去，然后投到了去哪儿，希望这能是一次愉快的经历。  

然后上学校的招聘网站看了看，感觉我能达到要求的企业还是有几家的，马上就把简历投过去吧，希望能有一份好工作。  

平心而论，我还是很希望能有一个技术向的工作，没办法，谁叫我这么喜欢编程呢~  

Fight！！  

#####~~~~~~~~~~~~我是萌萌的昏割线~~~~~~~~~~~~~  

```1410```：这道题很简单，题意就是把每一行的左右的```X```向中间对接，并保持左右对齐。那么```X```最多的那一行肯定能连接起来，而```X```较少的行中间就会存在空格，然后求出对接后空格的个数，输出即可。  

解题思路也很简单，就是找出所有行里面空格数最少的，然后用每一行的空格数减去这个最小值，把结果累加即可。  

这题的输入不能简单用```cin >> *chars```，因为```cin```输入字符串是会用空格分隔的，必须用```getline```，具体写法是：

	cin.getline(*str, 26);     //第一个参数是字符串指针，第二个是字符个数
	
这里要注意，因为字符串最后有一个```\0```的转义字符，所以```getline```的第二个参数一定要比字符串长度大一个。  

其他都是一些小问题了，比如循环里面有一点小错误，改了条件就好了，话说这个题我用```Ruby```写了一下试试，才用了十几行，脚本语言写起来还是爽啊~  

话不多说，代码如下：

    #include <iostream>
    #include <cstring>
    #include <string>
    using namespace std;

    int main(){
        int N, result, space_num[20], min, tmp;
        char chars[26];
        while(cin >> N && N){
            result = 0;
            for(int i = 0; i <= N; i++){
                cin.getline(chars, 26);
                tmp = 0;
                for(int j = 0; j < 25; j++){
                    if(chars[j] == ' ')
                        tmp++;
                }
                space_num[i] = tmp;
            }
            min = space_num[1];
            for(int i = 1; i <= N; i++){
                if(space_num[i] <= min)
                    min = space_num[i];
            }
            for(int i = 1; i <= N; i++)
                result += space_num[i] - min;
            cout << result << endl;
        }
    }