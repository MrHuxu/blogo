今天来看一个 Go 项目的源码: [gin: Live reload utility for Go web servers](https://github.com/codegangsta/gin).

这个项目的简介是实现 Go web server 的实时重载, 现在这个博客的 dev 模式就是使用这个项目启动的, 启动脚本如下:

    gin --excludeDir archives --excludeDir node_modules --excludeDir app/assets --all --port 8283 --appPort 13109 run main.go

忽略命令中的一串参数, 这行脚本的作用是, 整个项目对外暴露 `8283`, 请求会被重定向到 `13109` 端口上, 然后 `main.go` 是 go server 入口并且实现热重载, 这样分析之后我们我们可以把这个问题分成两个部分:

1. 怎么在内部做 http 数据包的转发
2. 怎么在内部启动和停止一个 go server

带着这两个问题, 我们直接开始看源码吧, 以下代码都省略了无关代码:

    // main.go
    func MainAction(c *cli.Context) {
	    os.Setenv("PORT", appPort)

      wd, err := os.Getwd()

      buildArgs, err := shellwords.Parse(c.GlobalString("buildArgs"))

      buildPath := c.GlobalString("build")
      builder := gin.NewBuilder(buildPath, c.GlobalString("bin"), c.GlobalBool("godep"), wd, buildArgs)
      runner := gin.NewRunner(filepath.Join(wd, builder.Binary()), c.Args()...)
      runner.SetWriter(os.Stdout)
      proxy := gin.NewProxy(builder, runner)

      config := &gin.Config{
        Laddr:    laddr,
        Port:     port,
        ProxyTo:  "http://localhost:" + appPort,
        KeyFile:  keyFile,
        CertFile: certFile,
      }

      err = proxy.Run(config)

      shutdown(runner)

      build(builder, runner, logger)

      // scan for changes
      scanChanges(c.GlobalString("path"), c.GlobalStringSlice("excludeDir"), all, func(path string) {
        runner.Kill()
        build(builder, runner, logger)
      })
    }

在这段入口里, 首先把需要转发的端口放到了环境变量里, 然后取了三个在编译 go server 时需要用到的常量:

1. `wd`: 当前的工作目录;
2. `buildArgs`: 构建参数;
3. `buildPath`: 构建 go server 的路径.

接下来我们可以看到, 整个 gin 项目把代码分成了三个模块, 分别是:

1. `builder`: 使用上面的三个常量来构建内部 go server;

        // lib/builder.go
        type builder struct {
          dir       string                  // 构建的目录
          binary    string                  // 构建得到的二进制文件
          wd        string                  // 当前工作目录
          buildArgs []string                // 构建参数
        }

2. `runner`: 负责运行和停止内部 go server;

        // lib/runner.go
        type runner struct {
          bin       string                  // builder 构建的二进制文件路径
          command   *exec.Cmd               // 使用二进制文件得到的 Command 实例
          starttime time.Time               // 当前内部 go server 进程开始的时间
        }

3. `proxy`: 将外部的 http/https 请求转发到内部的 go server 上.

        // lib/proxy.go
        type Proxy struct {
          listener net.Listener             // 监听网络请求
          proxy    *httputil.ReverseProxy   // ReverseProxy 实例, 实现反响代码数据转发
          builder  Builder                  // Builder 接口实例
          runner   Runner                   // Runner 接口实例
          to       *url.URL                 // 反响代理的地址
        }

下面就是针对这三个模块的 new 函数:

1. `NewBuilder`: 编译内部 server, 获得二进制文件信息, 返回实现了 `Builder` 接口的 `builder` 实例;
2. `NewRunner`: 使用 builder 信息生成 `exec.Command` 实例, 返回实现了 `Runner` 接口的 `runner` 实例;
3. `NewProxy`: 使用 `builder` 和 `runner` 生成 `Proxy` 实例, 其他字段暂时置为空.

接下俩就是调用 `Run` 方法来启动 proxy, 实现网络请求的转发:

    config := &gin.Config{
      Laddr:    laddr,
      Port:     port,
      ProxyTo:  "http://localhost:" + appPort,
      KeyFile:  keyFile,
      CertFile: certFile,
    }

    err = proxy.Run(config)

下面我们来看一下 Run 方法的具体实现:

    // proxy.go
    func (p *Proxy) Run(config *Config) error {
      url, err := url.Parse(config.ProxyTo)
      p.proxy = httputil.NewSingleHostReverseProxy(url)
      p.to = url

      server := http.Server{Handler: http.HandlerFunc(p.defaultHandler)}

      // 省略 https 的处理代码
      p.listener, err = net.Listen("tcp", fmt.Sprintf("%s:%d", config.Laddr, config.Port))

      go server.Serve(p.listener)

      return nil
    }

    func (p *Proxy) defaultHandler(res http.ResponseWriter, req *http.Request) {
      errors := p.builder.Errors()
      if len(errors) > 0 {
        res.Write([]byte(errors))
      } else {
        p.runner.Run()
        p.proxy.ServeHTTP(res, req)
      }
    }
